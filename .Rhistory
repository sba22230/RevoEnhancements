devtools::load_all(".")
install.packages("hexbin")
install.packages("hexbin")
devtools::load_all(".")
install.packages("devtools")
install.packages("devtools")
search()
devtools::load_all(".")
install.packages("mlbench")
library(RevoEnhancements)
sampleRXD <- function(iNRows = 1E4,
rxData = "work\split.TrainingValidation.T.xdf",
outFile = NULL){
iTotalRows <- rxGetInfo(rxData)$numRows
dPropData <- iNRows/iTotalRows
.e <- new.env(parent = baseenv())
assign("dPropData", dPropData, envir = .e)
sampleFunction <- function(datalist){
n <- length(datalist[[1]])
t <- round(n * dPropData)
tv <- rep(c(TRUE, FALSE), c(t, n-t))
datalist <- lapply(datalist, function(x){
x[tv]
})
datalist
}
rxDataStep(inData = rxData, outFile = outFile, transformFunc = sampleFunction)
}
sampleRXD <- function(iNRows = 1E4,
rxData = "work\split.TrainingValidation.T.xdf",
outFile = NULL){
iTotalRows <- rxGetInfo(rxData)$numRows
dPropData <- iNRows/iTotalRows
.e <- new.env(parent = baseenv())
assign("dPropData", dPropData, envir = .e)
sampleFunction <- function(datalist){
n <- length(datalist[[1]])
t <- round(n * dPropData)
tv <- rep(c(TRUE, FALSE), c(t, n-t))
datalist <- lapply(datalist, function(x){
x[tv]
})
datalist
}
rxDataStep(inData = rxData, outFile = outFile, transformFunc = sampleFunction)
}
sampleRXD <- function(iNRows = 1E4,
rxData = "work/split.TrainingValidation.T.xdf",
outFile = NULL){
iTotalRows <- rxGetInfo(rxData)$numRows
dPropData <- iNRows/iTotalRows
.e <- new.env(parent = baseenv())
assign("dPropData", dPropData, envir = .e)
sampleFunction <- function(datalist){
n <- length(datalist[[1]])
t <- round(n * dPropData)
tv <- rep(c(TRUE, FALSE), c(t, n-t))
datalist <- lapply(datalist, function(x){
x[tv]
})
datalist
}
rxDataStep(inData = rxData, outFile = outFile, transformFunc = sampleFunction)
}
?rxGlm
?rxGetOption
require(devtools)
rxLinPredError <- function (actualVarName, predVarName, data, sWeights = NULL, blocksPerRead = 1,
reportProgress = rxGetOption("reportProgress")) {
if(exists("data", mode = "list")){
numRow = nrow(data)
}else{
datInfo <- rxGetInfo(data)
numRow <- datInfo$numRows
}
.rxGet <- function() {}
.rxSet <- function() {}
rm(.rxGet, .rxSet)
BlockCompute <- function(datalist){
# Getting the data
dActualY <- datalist[[actualVarName]]
dPredY <- datalist[[predVarName]]
# Error
dError <- (dPredY - dActualY)
# Missing boolean
bMissing <- is.na(dError)
# Keeping only non-missing data
dError <- dError[!bMissing]
# Weights
if(is.null(sWeights)){
dWeights <- rep(1, length(dError))/numRow
}else{
dWeights <- datalist[[sWeights]]
}
dWeights <- dWeights[!bMissing]
dActualY <- dActualY[!bMissing]
# For MAPE
dSumABSPropError <- sum(abs(dError/dActualY))
# For MPE
dSumPropError <- sum(dError/dActualY)
# For RSS
RSS <- sum(dError^2)
# Weighted errors
dSumSQWeightedErrors <- sum(dWeights*(dError^2))
.rxSet("dSumABSPropError", .rxGet("dSumABSPropError") + dSumABSPropError)
.rxSet("dSumPropError", .rxGet("dSumPropError") + dSumPropError)
.rxSet("dSumWeights", .rxGet("dSumWeights") + sum(dWeights))
.rxSet("dSumSQWeightedErrors", .rxGet("dSumSQWeightedErrors") + dSumSQWeightedErrors)
.rxSet("RSS", .rxGet("RSS") + RSS)
.rxSet("N", .rxGet("N") + length(dError))
return(NULL)
}
ret <- rxDataStep(
inData = data,
varsToKeep = c(actualVarName, predVarName, sWeights),
blocksPerRead = blocksPerRead,
reportProgress = reportProgress,
returnTransformObjects = TRUE,
transformFunc = BlockCompute,
transformObjects = list(dSumABSPropError = 0, dSumPropError = 0, dSumWeights = 0,
dSumSQWeightedErrors = 0, RSS = 0, N = 0)
)
# Retreiving the values
dSumABSPropError <- ret[["dSumABSPropError"]]
dSumPropError <- ret[["dSumPropError"]]
dSumWeights <- ret[["dSumWeights"]]
dSumSQWeightedErrors <- ret[["dSumSQWeightedErrors"]]
RSS <- ret[["RSS"]]
N <- ret[["N"]]
MAPE <- dSumABSPropError/N
MPE <- dSumPropError/N
MSE <- RSS/N
MSWD <- (dSumSQWeightedErrors)*((N-1)*dSumWeights/N)
list(MAPE = MAPE, MPE = MPE, MSE = MSE, MSWD = MSWD)
}
fit <- rxLinMod(Sepal.Length ~ Petal.Length + Petal.Width, data = iris)
prd <- rxPredict(fit, iris)$Sepal.Length_Pred
dat <- data.frame(Sepal.Length=iris$Sepal.Length, Sepal.Length_Pred=prd, Weights = rep(1, nrow(iris))/nrow(iris))
rxLinPredError("Sepal.Length", "Sepal.Length_Pred", data=dat, sWeights="Weights")
rxLinPredError("Sepal.Length", "Sepal.Length_Pred", data=dat)
library(RevoEnhancements)
library(RevoEnhancements)
rxGetOption("sampleDataDir")
?rxDataStep
library(RevoEnhancements)
require(roxygenize)
require(roxygen)
require(roxygen2)
?roxygenize
getwd()
setwd("../")
getwd()
roxygenize("RevoEnhancements")
roxygenize("RevoEnhancements")
data = "work/split.TrainingValidation.T.xdf"
size = 1E6; replace = FALSE; maxRowsByCols = 220E6
extraRows <- 100
dataInfo <- rxGetInfo(data, getVarInfo = TRUE)
oneVar <- names(dataInfo$varInfo[1])
dataSize <- dataInfo$numRows
if (size > 1) {
p <- size / dataSize
} else if (size > 0) {
size <- ceiling(size * dataSize)
p <- size / dataSize
} else {
stop("'size' must be greater than zero")
}
if (is.data.frame(data)) {
mySamp <- sample.int(n = dataSize, size = size,
replace = ifelse(size > dataSize, TRUE, replace))
return(data[mySamp,])
}
createRandomSample <- function(dataList) {
# Trick to pass R CMD check: create and remove variables without binding
.rxStartRow <- .rxChunkNum <- function(){}
rm(.rxStartRow, .rxChunkNum)
zP <- character()
rm(zP)
numRows <- length(dataList[[1]])
dataList$.rxRowSelection <- as.logical(rbinom(numRows,1, zP))
return(dataList)
}
createRandomSampleReplace <- function(dataList) {
# Trick to pass R CMD check: create and remove variables without binding
.rxGet <- .rxSet <- .rxStartRow <- .rxChunkNum <- function() {}
rm(.rxGet, .rxSet, .rxStartRow, .rxChunkNum)
numRows <- length(dataList[[1]])
rowNum <- seq_len(numRows) + .rxStartRow - 1
rows <- sample[sample %in% rowNum]
tmpDf <- as.data.frame(dataList)[rows - .rxStartRow + 1,]
row.names(tmpDf) <- as.numeric(row.names(tmpDf)) + .rxStartRow - 1
ret[[.rxChunkNum]] <- tmpDf
.rxSet("ret", ret)
return(NULL)
}
replace
newP <- p + extraRows / dataSize
ret <- head(rxDataStep(data,
transformFunc = createRandomSample,
transformVars = oneVar,
transformObjects = list(zP = newP),
maxRowsByCols = maxRowsByCols),
n = size)
}
newP <- p + extraRows / dataSize
ret <- head(rxDataStep(data,
transformFunc = createRandomSample,
transformVars = oneVar,
transformObjects = list(zP = newP),
maxRowsByCols = maxRowsByCols),
n = size)
library(RevoEnhancements)
setwd("..\")
setwd("../")
require(roxygen)
require(roxygen2)
roxygenize("RevoEnhancements")
library(RevoEnhancements)
rxSample2Df
?rxDataStep
require(roxygen2)
setwd("..\")
setwd("../")
roxygenize("RevoScaleR")
roxygenize("RevoEnhancements")
args(rxFormula)
repos.date <- "2019-02-01"
ppm_cran <- sprintf("https://packagemanager.posit.co/cran/%s/", repos.date)
current_repos <- getOption("repos")
other_repos <- current_repos[setdiff(names(current_repos), "CRAN")]
options(repos = c(other_repos, CRAN = ppm_cran))
# Verify
getOption("repos")
install.packages('hexbin')
source("L:/Source/Repos/Azure-TDSP-Utilities-2025/Azure-TDSP-Utilities-master/DataScienceUtilities/DataReport-Utils/MRS/Run-IDEAR-MRS.R")
library(devtools, lib.loc = "C:/Program Files/Microsoft/R Client/R_SERVER/library")
remove.packages("devtools", lib = "C:/Program Files/Microsoft/R Client/R_SERVER/library")
# Set Posit Package Manager snapshot as the sole CRAN repository
repos.date <- "2019-02-01"
ppm_cran <- sprintf("https://packagemanager.posit.co/cran/%s/", repos.date)
current_repos <- getOption("repos")
other_repos <- current_repos[setdiff(names(current_repos), "CRAN")]
options(repos = c(other_repos, CRAN = ppm_cran))
# Verify
getOption("repos")
install.packages('devtools')
library(devtools)
sessionInfo()
installed.packages()[c("Package","Version","Built")]
# Helper to install from CRAN Archive
install_from_archive <- function(pkg, version) {
tryCatch({
url <- sprintf("https://cran.r-project.org/src/contrib/Archive/%s/%s_%s.tar.gz",
pkg, pkg, version)
message("Installing ", pkg, " version ", version)
install.packages(url, repos = NULL, type = "source", dependencies = FALSE)
}, error = function(e) {
cat("Error installing package", pkg, ":", e$message, "\n")
cat("Please install", pkg, "manually and try again.\n")
stop("Package installation failed")
})
}
install_from_archive("devtools", "2.0.1")   # or the devtools version you want
source("L:/Source/Repos/Azure-TDSP-Utilities-2025/Azure-TDSP-Utilities-master/DataScienceUtilities/DataReport-Utils/MRS/Run-IDEAR-MRS.R")
source("L:/Source/Repos/Azure-TDSP-Utilities-2025/Azure-TDSP-Utilities-master/DataScienceUtilities/DataReport-Utils/MRS/Run-IDEAR-MRS.R")
library(RevoEnhancements)
library(RevoScaleR)
RevoUtils::totalSystemMemory()
library(RevoScaleR)
if(require("e1071")){
skewness(iris$Sepal.Length, type=3)
skewness(iris$Sepal.Width, type=1)
kurtosis(iris$Sepal.Length, type=3)
kurtosis(iris$Sepal.Width, type=1)
}
rxMoments(~ Sepal.Length + Sepal.Width, iris)
install.packages("e1071")
library(RevoScaleR)
if(require("e1071")){
skewness(iris$Sepal.Length, type=3)
skewness(iris$Sepal.Width, type=1)
kurtosis(iris$Sepal.Length, type=3)
kurtosis(iris$Sepal.Width, type=1)
}
rxMoments(~ Sepal.Length + Sepal.Width, iris)
rxMoments(~ Sepal.Width + Sepal.Length, iris)
formula <- as.formula(~ Sepal.Length + Sepal.Width, iris)
all.vars(formula)
formVars <- all.vars(as.formula(formula))
formVars <- all.vars(formula)
calcMoments <- function(datalist){
n     <- vapply(datalist, function(x)length(x), FUN.VALUE=0, USE.NAMES=FALSE)
sumx  <- vapply(datalist, function(x)sum(x),   FUN.VALUE=0, USE.NAMES=FALSE)
sumx2 <- vapply(datalist, function(x)sum(x^2), FUN.VALUE=0, USE.NAMES=FALSE)
sumx3 <- vapply(datalist, function(x)sum(x^3), FUN.VALUE=0, USE.NAMES=FALSE)
sumx4 <- vapply(datalist, function(x)sum(x^4), FUN.VALUE=0, USE.NAMES=FALSE)
.rxModify("n",     n,     FUN="+")
.rxModify("sumx",  sumx,  FUN="+")
.rxModify("sumx2", sumx2, FUN="+")
.rxModify("sumx3", sumx3, FUN="+")
.rxModify("sumx4", sumx4, FUN="+")
return(NULL)
}
zz <- rxDataStep(inData, varsToKeep=formVars,
transformFunc=calcMoments,
transformObjects=list(
n = 0,
sumx  = rep(0, length(formVars)),
sumx2 = rep(0, length(formVars)),
sumx3 = rep(0, length(formVars)),
sumx4 = rep(0, length(formVars))
),
returnTransformObjects=TRUE,
transformEnvir=new.env(),
...
)
inData <- iris
zz <- rxDataStep(inData, varsToKeep=formVars,
transformFunc=calcMoments,
transformObjects=list(
n = 0,
sumx  = rep(0, length(formVars)),
sumx2 = rep(0, length(formVars)),
sumx3 = rep(0, length(formVars)),
sumx4 = rep(0, length(formVars))
),
returnTransformObjects=TRUE,
transformEnvir=new.env(),
...
)
n     <- zz[["n"]]
rxMoments <- function(formula, inData=NULL, ...){
.rxModify <- NULL # trick to pass R CMD check
formVars <- all.vars(as.formula(formula))
calcMoments <- function(datalist){
n     <- vapply(datalist, function(x)length(x), FUN.VALUE=0, USE.NAMES=FALSE)
sumx  <- vapply(datalist, function(x)sum(x),   FUN.VALUE=0, USE.NAMES=FALSE)
sumx2 <- vapply(datalist, function(x)sum(x^2), FUN.VALUE=0, USE.NAMES=FALSE)
sumx3 <- vapply(datalist, function(x)sum(x^3), FUN.VALUE=0, USE.NAMES=FALSE)
sumx4 <- vapply(datalist, function(x)sum(x^4), FUN.VALUE=0, USE.NAMES=FALSE)
.rxModify("n",     n,     FUN="+")
.rxModify("sumx",  sumx,  FUN="+")
.rxModify("sumx2", sumx2, FUN="+")
.rxModify("sumx3", sumx3, FUN="+")
.rxModify("sumx4", sumx4, FUN="+")
return(NULL)
}
zz <- rxDataStep(inData, varsToKeep=formVars,
transformFunc=calcMoments,
transformObjects=list(
n = 0,
sumx  = rep(0, length(formVars)),
sumx2 = rep(0, length(formVars)),
sumx3 = rep(0, length(formVars)),
sumx4 = rep(0, length(formVars))
),
returnTransformObjects=TRUE,
transformEnvir=new.env(),
...
)
n     <- zz[["n"]]
sumx  <- zz[["sumx"]]
sumx2 <- zz[["sumx2"]]
sumx3 <- zz[["sumx3"]]
sumx4 <- zz[["sumx4"]]
# m2 : sum(x^2) - 1/n * sum(x)^2
# m3 : sum(x^3)  -  3/n * sum(x^2)*sum(x)  +  3/n^2 * sum(x)^3  -  1/n^2 * sum(x)^3
# m4 : sum(x^4)  -  4/n * sum(x^3)*sum(x)  +  6/n^2 * sum(x^2)*sum(x)^2  -  4/n^3 * sum(x)^4  +  1/n^3 * sum(x)^4
m2 <- (sumx2 - 1/n * sumx^2) / n
m3 <- (sumx3 -3/n * sumx2*sumx + 3/n^2 * sumx^3 - 1/n^2 * sumx^3) / n
m4 <- (sumx4 - 4/n * sumx3*sumx + 6/n^2 * sumx2*sumx^2 - 4/n^3 * sumx^4 + 1/n^3 * sumx^4) / n
# skewness
g1 <- m3 / m2^1.5                  # In textbooks
G1 <- g1 * sqrt(n * (n-1)) / (n-2) # In SAS/SPSS
b1 <- g1 * ((n-1)/n)^1.5           # In Minitab and BDMP
# kurtosis
g2 <- m4 / m2^2 - 3                        # In textbooks
G2 <- ((n+1)*g2 + 6) * (n-1)/((n-2)*(n-3)) # In SAS/SPSS
b2 <- (g2 + 3) * (1 - 1/n)^2 - 3           # In Minitab and BDMP
list(
moments  = list(m2=m2, m3=m3, m4=m4),
skewness = list(g1=g1, G1=G1, b1=b1),
kurtosis = list(g2=g2, G2=G2, b2=b2)
)
}
rxMoments(~ Sepal.Width + Sepal.Length, iris)
irisXdf <- RxXdfData(tempfile())
rxDataStep(inData = iris, outFile = irisXdf, overwrite = TRUE)
rxMoments(~ Sepal.Width + Sepal.Length, irisXdf)
irisXdf <- RxXdfData(tempfile())
rxDataStep(inData = iris, outFile = irisXdf, overwrite = TRUE)
rxMoments(~ Sepal.Width + Sepal.Length, irisXdf)
?rxDataStep()
# Create a data frame
set.seed(100)
myData <- data.frame(x = 1:100, y = rep(c("a", "b", "c", "d"), 25),
z = rnorm(100), w = runif(100))
# Get a subset rows and columns from the data frame
myDataSubset <- rxDataStep(inData = myData,
varsToKeep = c("x", "w", "z"), rowSelection = z > 0)
install.packages("L:/RPackages/R4.0.2/RevoScaleR_10.0.1.zip", repos = NULL, type = "win.binary")
detach("package:RevoScaleR", unload = TRUE)
install.packages("L:/RPackages/R4.0.2/RevoScaleR_10.0.1.zip", repos = NULL, type = "win.binary")
use warnings()
warnings()
library(RevoEnhancements)
library(RevoIOQ)
library(RevoScaleR)
library(RevoUtils)
RevoLicense()
revo()
forum()
rxInstalledPackages()
rxInstalledPackages(fields = NULL)
